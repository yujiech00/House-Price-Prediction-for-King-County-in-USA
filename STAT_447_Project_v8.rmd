---
title: "STAT 447 Project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(vtable)
library(ggplot2)
library(gridExtra)
library(RColorBrewer)
library(ggcorrplot)
library(tidyverse)
library(readxl)
library(quantregForest)
library(olsrr)
library(MASS)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r data Import}
#Step1 - Importing and reading the data

kv_house_data = read.csv("/Users/yujiech/Desktop/STAT 447/Group Project/kc_house_data.csv")
 # kv_house_data = read.csv("/Users/liushuyan/Desktop/STAT447B/Project/kc_house_data.csv")
#kv_house_data = read.csv("kc_house_data.csv")
names(kv_house_data)

zipcode_region = read.csv("/Users/yujiech/Desktop/STAT 447/Group Project/Zipcode.csv", header=T)
# zipcode_region = read.csv("/Users/liushuyan/Desktop/STAT447B/Project/Zipcode.csv", header=T)
#zipcode_region = read.csv("/Users/liang/OneDrive/Desktop/UBC Courses Year 4/Term 2/STAT447B/Project/Zipcode.csv", header=T)

```

```{r add extra columns}

# create year and month columns from date column
kv_house_data$year = substr(kv_house_data$date, 1,4)
kv_house_data$month = substr(kv_house_data$date, 5,6)

# add columns: ratio_lotliving, unitPrice
kv_house_data$ratio_lotliving = kv_house_data$sqft_lot/kv_house_data$sqft_living
kv_house_data$unitPrice = kv_house_data$price/kv_house_data$sqft_living

# add column: region => group zipcode
kv_house_data = left_join(kv_house_data, zipcode_region, by="zipcode")

kv_house_data$region = as.factor(kv_house_data$region)
# View(kv_house_data)

# add column: diff_yr_renovated_and_year = year-yr_renovated if yr_renovated !=0 else NA
kv_house_data$diff_yr_renovated_and_year = as.integer(kv_house_data$year)-kv_house_data$yr_renovated
kv_house_data$diff_yr_renovated_and_year[kv_house_data$yr_renovated==0] = NA

# binning for diff_yr_renovated_and_year or yr_renovated
# add column: renovation (3 levels: never renovated, renovated long time ago, renovated recently)
kv_house_data$renovation = "renovated long time ago"
kv_house_data$renovation[kv_house_data$diff_yr_renovated_and_year<=20] = "renovated recently"
kv_house_data$renovation[kv_house_data$yr_renovated==0] = "never renovated"
kv_house_data$renovation = as.factor(kv_house_data$renovation)

# binning for sqft_basement
# add column: basement (tw0 levels: 1 if sqft_basement !=0 else 0)
kv_house_data$basement = 0
kv_house_data$basement[kv_house_data$sqft_basement!=0] = 1
kv_house_data$basement = as.factor(kv_house_data$basement)
```

```{r data cleasing}

# Select a threshold for separating family houses and farm land => Use 10 as the threshold
par(mfrow=c(1,2))
hist(kv_house_data$ratio_lotliving, main = "ratio_lotliving", xlab = "ratio_lotliving")
hist(kv_house_data$ratio_lotliving[kv_house_data$ratio_lotliving<10],
     main = "ratio_lotliving (ratio<10)", xlab = "ratio_lotliving")
nrow(kv_house_data) # total: 21613
sum(kv_house_data$ratio_lotliving>=10) # farm land: 2426
sum(kv_house_data$ratio_lotliving<10) # family houses: 19187

# We focus on all the family houses, exclude farm land in this project
kv_house_data_family = kv_house_data[kv_house_data$ratio_lotliving<10,]
hist(kv_house_data_family$ratio_lotliving)
boxplot(kv_house_data_family$ratio_lotliving,main = "ratio_lotliving (ratio<10)")
hist(kv_house_data_family$sqft_living)
boxplot(kv_house_data_family$sqft_living)

# Remove extreme values: no bedrooms or no bathrooms
kv_house_data_family = subset(kv_house_data_family, subset = (kv_house_data_family$bedrooms!=0 & kv_house_data_family$bathrooms!=0))

# bedrooms - remove the bedrooms is 33 and bedrooms > 12
kv_house_data_family = subset(kv_house_data_family, subset = (kv_house_data_family$bedrooms<=12))
hist(kv_house_data_family$bedrooms, xlab="bedrooms", main="bedrooms (remove)")
boxplot(kv_house_data_family$bedrooms, ylab="bedrooms", main="bedrooms (remove)")

# Use unitPrice=price/sqft_living as response variable
par(mfrow=c(1,2))
hist(kv_house_data_family$price, main = "price", xlab = "price")
boxplot(kv_house_data_family$price, main = "price", xlab = "price")
hist(kv_house_data_family$unitPrice, main = "unit price", xlab = "unit price")
boxplot(kv_house_data_family$unitPrice, main = "unit price", xlab = "unit price")

# Summary the numerical feature values before drop
st(kv_house_data_family[,sapply(kv_house_data_family,is.numeric)])

# Drop columns: id, date, lat, long, zipcode
names(kv_house_data_family)
kv_house_data_family = subset(kv_house_data_family, select = -c(id, date, lat, long, zipcode))
# Summary the numerical feature values after drop
st(kv_house_data_family[,sapply(kv_house_data_family,is.numeric)])

# Count the missing values by column wise
print("Count of missing values by column wise")
count_of_missing_values = sapply(kv_house_data_family, function(x) sum(is.na(x)))
data.frame(count_of_missing_values)

# Convert column "waterfront", "view", "condition", "grade", "year", "month", "basement", "renovation", "region" to factor
names(kv_house_data_family)
cat_cols = c("waterfront", "view", "condition", "grade", "year", "month", "basement", "renovation", "region")
kv_house_data_family[cat_cols] <- lapply(kv_house_data_family[cat_cols], as.factor)



```
```{r data transformation}
# unitPrice
par(mfrow=c(1,2))
hist(kv_house_data_family$unitPrice, xlab="unitPrice", col="lightgrey", main="unitPrice")
hist(log(kv_house_data_family$unitPrice), xlab="log(unitPrice)", col="lightgrey", main="log(unitPrice)")
boxplot(log(kv_house_data_family$unitPrice), xlab="log(unitPrice)", main="log(unitPrice)")

# sqft_living => log(sqft_living)
par(mfrow=c(1,2))
hist(kv_house_data_family$sqft_living, xlab="sqft_living", col="lightgrey", main="sqft_living")
hist(log(kv_house_data_family$sqft_living), xlab="log(sqft_living)", col="lightgrey", main="log(kv_house_data_family$sqft_living)")
boxplot(log(kv_house_data_family$sqft_living), xlab="log(sqft_living)", main="log(sqft_living)")
kv_house_data_family$log_sqft_living = log(kv_house_data_family$sqft_living)

# sqft_lot => log(sqft_lot)
par(mfrow=c(1,2))
hist(kv_house_data_family$sqft_lot, xlab="sqft_lot", col="lightgrey", main="sqft_lot")
hist(log(kv_house_data_family$sqft_lot), xlab="log(sqft_lot)", col="lightgrey", main="log(sqft_lot)")
boxplot(log(kv_house_data_family$sqft_lot), xlab="log(sqft_lot)",
        main="log(sqft_lot)")
kv_house_data_family$log_sqft_lot = log(kv_house_data_family$sqft_lot)

# sqft_lot15 => log(sqft_lot15)
par(mfrow=c(1,2))
hist(kv_house_data_family$sqft_lot15, xlab="sqft_lot15", col="lightgrey", main="sqft_lot15")
hist(log(kv_house_data_family$sqft_lot15), xlab="log(sqft_lot15)", 
     col="lightgrey", main="log(sqft_lot15)")
boxplot(log(kv_house_data_family$sqft_lot15), xlab="log(sqft_lot15)", 
        main="log(sqft_lot15)")
kv_house_data_family$log_sqft_lot15 = log(kv_house_data_family$sqft_lot15)

head(kv_house_data_family)
```

```{r data visualizations}
# get numeric columns
varnames = names(kv_house_data_family)
numeric_or_not = sapply(kv_house_data_family, is.numeric)
numeric_col_indices = which(numeric_or_not==TRUE)

# boxplots for numerical variables
boxplot_list = list()
for (i in 1: length(numeric_col_indices)) {
  curr_col_index = numeric_col_indices[i]
  p = ggplot(kv_house_data_family, aes_string(y=varnames[curr_col_index])) + 
    geom_boxplot(color="#454545", fill="orange", alpha=0.5) +
    theme(legend.position="none")
  boxplot_list[[i]] <- p
}
grid.arrange(grobs=boxplot_list, ncol=4)
# save
g <- arrangeGrob(grobs=boxplot_list, ncol=4)
ggsave(file="/Users/yujiech/Desktop/STAT 447/Group Project/plots/Presentation 2/boxplot_list.png", g)

# side-by-side boxplots for categorical variables
sidebyside_boxplot_list = list()
for (i in 1:length(cat_cols)) {
  y = kv_house_data_family$price
  x = kv_house_data_family[, cat_cols[i]]
  p = ggplot(kv_house_data_family, aes_string(x=cat_cols[i], y="unitPrice",fill=cat_cols[i])) + 
    geom_boxplot(alpha=0.3) +
    theme(legend.position="none")
  sidebyside_boxplot_list[[i]] <- p
}
grid.arrange(grobs=sidebyside_boxplot_list[c(1, 2)], ncol=2)
grid.arrange(grobs=sidebyside_boxplot_list[c(3, 4)], ncol=2)
grid.arrange(grobs=sidebyside_boxplot_list[c(5, 6)], ncol=2)
# save
g <- arrangeGrob(grobs=sidebyside_boxplot_list[c(1, 2)], ncol=2)
# ggsave(file="/Users/liushuyan/Desktop/STAT447B/Project/image/sidebyside_boxplot_list_part1.png", g)
ggsave(file="/Users/yujiech/Desktop/STAT 447/Group Project/plots/Presentation 2/sidebyside_boxplot_list_part1.png", g)

g <- arrangeGrob(grobs=sidebyside_boxplot_list[c(3, 4)], ncol=2)
# ggsave(file="/Users/liushuyan/Desktop/STAT447B/Project/image/sidebyside_boxplot_list_part2.png", g)
ggsave(file="/Users/yujiech/Desktop/STAT 447/Group Project/plots/Presentation 2/sidebyside_boxplot_list_part2.png", g)
g <- arrangeGrob(grobs=sidebyside_boxplot_list[c(5, 6)], ncol=2)
# ggsave(file="/Users/liushuyan/Desktop/STAT447B/Project/image/sidebyside_boxplot_list_part3.png", g)
ggsave(file="/Users/yujiech/Desktop/STAT 447/Group Project/plots/Presentation 2/sidebyside_boxplot_list_part3.png", g)

# side-by-side boxplots for bedrooms and floors
sidebyside_boxplot_list_extra = list()
y = kv_house_data_family$price
kv_house_data_family$bedrooms = as.factor(kv_house_data_family$bedrooms)
kv_house_data_family$floors = as.factor(kv_house_data_family$floors)
sidebyside_boxplot_list_extra[[1]] = ggplot(kv_house_data_family, aes(x=bedrooms, y=unitPrice,fill=bedrooms)) + 
    geom_boxplot(alpha=0.3) +
    theme(legend.position="none")
sidebyside_boxplot_list_extra[[2]] = ggplot(kv_house_data_family, aes(x=floors, y=unitPrice,fill=floors)) + 
    geom_boxplot(alpha=0.3) +
    theme(legend.position="none")
grid.arrange(grobs=sidebyside_boxplot_list_extra, ncol=2)
# save
g <- arrangeGrob(grobs=sidebyside_boxplot_list_extra, ncol=2)
# ggsave(file="/Users/liushuyan/Desktop/STAT447B/Project/image/sidebyside_boxplot_list_extra.png", g)
ggsave(file="/Users/yujiech/Desktop/STAT 447/Group Project/plots/Presentation 2/sidebyside_boxplot_list_extra.png", g)
kv_house_data_family$bedrooms = as.numeric(kv_house_data_family$bedrooms)
kv_house_data_family$floors = as.numeric(kv_house_data_family$floors)

# trend plot for mean price over month
mean_price_over_month <- as.data.frame(
  kv_house_data_family %>%
  group_by(month) %>%
  summarise(mean_price = mean(price))
)
mean_price_over_month$month = as.numeric(mean_price_over_month$month)
print(ggplot(mean_price_over_month, aes(x=month, y=mean_price)) + 
        geom_line() + 
        scale_x_continuous(breaks=seq(1,12,1)) +
        ggtitle("price trend"))

# histograms for numerical variables
par(mfrow=c(3,3))
for (i in 1: length(numeric_col_indices)) {
  curr_col_index = numeric_col_indices[i] 
  hist(kv_house_data_family[, curr_col_index], xlab=varnames[curr_col_index], col="lightgrey", main="")
}

# spearman correlation matrix
kv_house_data_family$view = as.numeric(kv_house_data_family$view)
kv_house_data_family$condition = as.numeric(kv_house_data_family$condition)
kv_house_data_family$grade = as.numeric(kv_house_data_family$grade)
temp = which(sapply(kv_house_data_family, is.numeric)==TRUE)
temp = temp[which(names(temp)!="diff_yr_renovated_and_year")]
correlation_matrix = data.frame(round(cor(kv_house_data_family[ , temp], method="spearman"),1))
print(correlation_matrix) 
ggcorrplot(cor(x=kv_house_data_family[, temp], y=NULL, method="spearman"), hc.order = TRUE,
   outline.col = "white",
   ggtheme = ggplot2::theme_gray,
   colors = c("#6D9EC1", "white", "#E46726"))

```


```{r data visualizations for region}
# get all unique regions
unique_regions <- unique(kv_house_data$region)

# count the number of unique regions - 37 regions in total
num_regions <- length(unique_regions)
num_regions

#Boxplot for region
boxplot(kv_house_data_family$price ~ kv_house_data_family$region, 
        main = "Price by Region", xlab = "Region", ylab = "Price")

#Boxplot of unit price by region
boxplot(unitPrice ~ region, data = kv_house_data_family, xlab = "Region", ylab = "Unit Price")

#Histogram of unit price by region
ggplot(kv_house_data_family, aes(x = unitPrice, fill = region)) + 
  geom_histogram(position = "dodge", bins = 20) +
  labs(x = "Unit Price", y = "Count") +
  ggtitle("Histogram of Unit Price by Region") +
  theme_bw()

#Barplot of the count of houses by region
ggplot(kv_house_data_family, aes(x = region, fill = region)) + 
  geom_bar() +
  labs(x = "Region", y = "Count") +
  ggtitle("Count of Houses by Region") +
  theme_bw()

```

```{r remove unnecessary region data points and columns that will not be used in the model}

region_count = table(kv_house_data_family$region)
region_count = sort(region_count, decreasing = F)
minor_region = names(region_count)[1:6]
kv_house_data_family$region = as.character(kv_house_data_family$region)

kv_house_data_family_filtered = subset(kv_house_data_family, !region %in% minor_region)
kv_house_data_family_filtered$region = as.factor(kv_house_data_family_filtered$region)

# dataset for full model
kv_house_data_family_filtered = subset(kv_house_data_family_filtered, select = -c(diff_yr_renovated_and_year, sqft_living, sqft_lot, sqft_lot15, price, yr_renovated, ratio_lotliving))

```

```{r spearman matrix for kv_house_data_family_filtered}
temp2 = which(sapply(kv_house_data_family_filtered, is.numeric)==TRUE)
correlation_matrix2 = data.frame(round(cor(kv_house_data_family_filtered[ , temp2], method="spearman"),1))
print(correlation_matrix2) 
ggcorrplot(cor(x=kv_house_data_family_filtered[, temp2], y=NULL, method="spearman"), hc.order = TRUE,
   outline.col = "white",
   ggtheme = ggplot2::theme_gray,
   colors = c("#6D9EC1", "white", "#E46726"),
   lab = TRUE)
```

```{r remove columns with high multicollinearity}
# spearman correlation coefficient >=0.8
# (log_sqft_living, sqft_above) = 0.83; (log_sqft_lot, log_sqft_lot15) = 0.91
# we may need to delete one of the two variables in each pair, but we want to see the results from stepwise AIC feature selection first
```

```{r feature selection}
# split the data into training and testing datasets
set.seed(447)
train = sample(nrow(kv_house_data_family_filtered), nrow(kv_house_data_family_filtered) * 0.8)
kv_house_train = kv_house_data_family_filtered[train, ]
kv_house_test = kv_house_data_family_filtered[-train, ]

model_fSelect = lm(unitPrice ~., data = kv_house_train)
AICstep = stepAIC(model_fSelect, direction="both", trace=1, steps=20)
summary(AICstep) 

# after feature selection
# we remove sqft_basement, floors, log_sqft_lot
kv_house_data_family_filtered_after_feature_selection = subset(kv_house_data_family_filtered, select = -c(sqft_basement, floors, log_sqft_lot))
names(kv_house_data_family_filtered_after_feature_selection)
```

```{r diagonostic}
# multiple linear regression
multiple_lm_model = lm(unitPrice ~., data = kv_house_train)
plot(multiple_lm_model)
multiple_lm_model.res = resid(multiple_lm_model)
summary(multiple_lm_model)

plot(kv_house_train$log_sqft_living, multiple_lm_model.res,
     xlab="log_sqft_living", ylab="Residuals", 
     main = "")

plot(kv_house_train$bedrooms, multiple_lm_model.res,
     xlab="bedrooms", ylab="Residuals", 
     main = "")

plot(kv_house_train$yr_built, multiple_lm_model.res,
     xlab="yr_built", ylab="Residuals", 
     main = "")

plot(kv_house_train$sqft_above, multiple_lm_model.res,
     xlab="sqft_above", ylab="Residuals", 
     main = "")

plot(kv_house_train$log_sqft_lot, multiple_lm_model.res,
     xlab="log_sqft_lot", ylab="Residuals", 
     main = "")

plot(kv_house_train$sqft_living15, multiple_lm_model.res,
     xlab="sqft_living15", ylab="Residuals", 
     main = "")

plot(kv_house_train$floors, multiple_lm_model.res,
     xlab="floors", ylab="Residuals", 
     main = "")

```

```{r check multiple linear regression}
multiple_lm_model_subset_check = lm(unitPrice ~ bedrooms+bathrooms+waterfront+view+condition+grade^2+yr_built+sqft_living15+year+month+region+renovation+basement+log_sqft_living+log_sqft_lot15, data = kv_house_data_family_filtered)
summary(multiple_lm_model_subset_check)

multiple_lm_model_subset_check_original = lm(unitPrice ~ ., data = kv_house_data_family_filtered)
summary(multiple_lm_model_subset_check_original)
```




```{r save kv_house_data_family_filtered, kv_house_data_family_filtered_after_feature_selection}
saveRDS(kv_house_data_family_filtered, "/Users/yujiech/Desktop/STAT 447/Group Project/kv_house_data_family_filtered.rds")
# saveRDS(kv_house_data_family_filtered, "/Users/liushuyan/Desktop/STAT447B/Project/kv_house_data_family_filtered.rds")

saveRDS(kv_house_data_family_filtered_after_feature_selection, "/Users/yujiech/Desktop/STAT 447/Group Project/kv_house_data_family_filtered_after_feature_selection.rds")
# saveRDS(kv_house_data_family_filtered_after_feature_selection, "/Users/liushuyan/Desktop/STAT447B/Project/kv_house_data_family_filtered_after_feature_selection.rds")

```

```{r Cross Validation Template}
#' @param Kfold number of folds for cross-validation
#' @param iperm permutation vector for rows
#' @param datafr assume dataframe has y x1 ... xp, can modify below to be more general
#' @param nperfMeas number of performance measures
#' maybe could pass myMethod and myPredict as arguments
crossValidate = function(Kfold, iperm, datafr, nMLR) { 
  n = nrow(datafr); 
  nhold = round(n/Kfold)
  pred = list() # save predictions in order to be able to compare them for different methods
  
  # for storing performance measures
  perfMatMLR_0.5 = matrix(0,Kfold,nMLR*4)  
  perfMatMLR_0.8 = matrix(0,Kfold,nMLR*4)
  perfMatQRF_0.5 = matrix(0,Kfold,4)  
  perfMatQRF_0.8 = matrix(0,Kfold,4)

  for(k in 1:Kfold) { 
    ilow = (k-1)*nhold+1; ihigh = k*nhold
    if(k==Kfold) { ihigh = n }
    ifold = iperm[ilow:ihigh]
    myMethodObj = myMethod(datafr[-ifold,])
    pred[[k]] = myPredict(myMethodObj, datafr[ifold,]) 
    
    perfMatMLR_0.5[k,] = perfMeas(pred[[k]]$predMLR50, datafr[ifold,]$unitPrice * exp(datafr[ifold,]$log_sqft_living), 0.5, n_model=nMLR)
    perfMatMLR_0.8[k,] = perfMeas(pred[[k]]$predMLR80, datafr[ifold,]$unitPrice * exp(datafr[ifold,]$log_sqft_living), 0.8, n_model=nMLR)
    
    # pred[[k]]$predQRF50and80 has columns: "q0.1", "q0.25", "q0.5", "q0.75", "q0.9"
    perfMatQRF_0.5[k,] = perfMeas(pred[[k]]$predQRF50and80[, c("q0.5", "q0.25", "q0.75")], datafr[ifold,]$unitPrice * exp(datafr[ifold,]$log_sqft_living), 0.5)
    perfMatQRF_0.8[k,] = perfMeas(pred[[k]]$predQRF50and80[, c("q0.5", "q0.1", "q0.9")], datafr[ifold,]$unitPrice * exp(datafr[ifold,]$log_sqft_living), 0.8)
    
  }
  
  perfAverageMLR_0.5 = colMeans(perfMatMLR_0.5)
  perfAverageMLR_0.8 = colMeans(perfMatMLR_0.8)
  perfAverageQRF_0.5 = colMeans(perfMatQRF_0.5)
  perfAverageQRF_0.8 = colMeans(perfMatQRF_0.8)
  
  list(perfMatMLR_0.5=perfMatMLR_0.5, perfAverageMLR_0.5=perfAverageMLR_0.5, perfMatMLR_0.8=perfMatMLR_0.8, perfAverageMLR_0.8=perfAverageMLR_0.8, perfMatQRF_0.5=perfMatQRF_0.5, perfAverageQRF_0.5=perfAverageQRF_0.5, perfMatQRF_0.8=perfMatQRF_0.8, perfAverageQRF_0.8=perfAverageQRF_0.8, pred=pred)
  
}

```

```{r myMethod}

myMethod = function(train) {
  
  # fit the multiple regression model with all variables
  multiple_lm_model = lm(unitPrice ~., data = train)
  
  # fit the multiple regression model with a subset of variables (suggested by stepwise AIC feature selection)
  multiple_lm_model_subset = lm(unitPrice ~ bedrooms+bathrooms+waterfront+view+condition+grade^2+yr_built+sqft_living15+year+month+region+renovation+basement+log_sqft_living+log_sqft_lot15, data = train)
  
  #Fit the quantile random forest model
  qrf_x = subset(train, select = -c(unitPrice))
  qrf_y = train$unitPrice
  quantregForest_model = quantregForest(qrf_x, qrf_y, ntrees = 100) # ntrees changes to 100 instead of default value, save time here, otherwise it needs at least 20 minutes to run 
  
  list(multiple_lm_model=multiple_lm_model, multiple_lm_model_subset=multiple_lm_model_subset, quantregForest_model=quantregForest_model)
  
}

```

```{r myPredict}
# myPredict for a continuous response
# : returns prediction intervals of levels 50%, 80% etc
myPredict <- function(myMethodObj, holdout){
  
  n_model = length(myMethodObj) # one or more multiple linear regression models + one Quantile Random Forest
  predQRF50and80 = predict(myMethodObj[[n_model]], what=c(.1,.25, .5, .75, .9), newdata=holdout)
  
  predMLR50 = data.frame()
  predMLR80 = data.frame()
  
  for (i in 1:(n_model-1)) {
    pred50 = predict(myMethodObj[[i]], newdata=holdout, interval="prediction", level=0.5)
    pred80 = predict(myMethodObj[[i]], newdata=holdout, interval="prediction", level=0.8)
    if (i==1) {
      predMLR50 = pred50
      predMLR80 = pred80
    } else {
      predMLR50 = cbind(predMLR50, pred50)
      predMLR80 = cbind(predMLR80, pred80)
    }
  }
  
  predMLR50 = predMLR50 * exp(holdout$log_sqft_living)
  predMLR80 = predMLR80 * exp(holdout$log_sqft_living)
  predQRF50and80 = predQRF50and80 * exp(holdout$log_sqft_living)
  
  colnames(predMLR50)=c("fit0","lwr0","upr0","fit1","lwr1","upr1")
  colnames(predMLR80)=c("fit0","lwr0","upr0","fit1","lwr1","upr1")
  colnames(predQRF50and80) = c("q0.1", "q0.25", "q0.5", "q0.75", "q0.9")
  
  list(predMLR50=predMLR50, predMLR80=predMLR80, predQRF50and80=predQRF50and80)

}
```

```{r intervalScore}

intervalScore = function(predObj,actual,level, lwr_index, upr_index) { 
  n = nrow(predObj)
  alpha = 1-level
  ilow = (actual<predObj[,lwr_index]) # overestimation
  ihigh = (actual>predObj[,upr_index]) # underestimation
  sumlength = sum(predObj[,upr_index]-predObj[,lwr_index]) # sum of lengths of prediction intervals 
  sumlow = sum(predObj[ilow,lwr_index]-actual[ilow])*2/alpha
  sumhigh = sum(actual[ihigh]-predObj[ihigh,upr_index])*2/alpha
  avglength = sumlength/n
  IS = (sumlength+sumlow+sumhigh)/n # average length + average under/over penalties 
  cover = mean(actual>= predObj[,lwr_index] & actual<=predObj[,upr_index])
  summ = c(level,avglength,IS,cover)
  # summary with level, average length, interval score, coverage rate
  # imiss = which(ilow | ihigh)
  names(summ) = c("level","avglength","IS", "cover")
  summ
}

```

```{r perfMeas}
# perfMeas for a continuous response
# : returns several performance measures including
# average length of prediction intervals, interval scores and coverage rate at levels 50%. 80%

perfMeas <- function(predObj, holdout_y, level, n_model=1){
  
  perfMeas = matrix(0,1,4)
  # default value of n_model=1 => this means that this predObj onlt contains values for one model
  for (i in 1: n_model) {
    lwr_index = 2+3*(i-1)
    upr_index = 3*i
    curr = intervalScore(predObj, holdout_y, level, lwr_index, upr_index)
    if (i==1) {
      perfMeas = curr
    } else {
      perfMeas = c(perfMeas, curr)
    }
  }
  print(perfMeas)
  perfMeas
  
}
```

```{r import the cleaned and transformed dataset from files}

kv_house_data_family_filtered_for_CV = readRDS("/Users/yujiech/Desktop/STAT 447/Group Project/kv_house_data_family_filtered.rds")

# kv_house_data_family_filtered_for_CV = readRDS("/Users/liushuyan/Desktop/STAT447B/Project/kv_house_data_family_filtered.rds")

```

```{r apply CV - main function}

n = nrow(kv_house_data_family_filtered_for_CV) 
seed = 12345
set.seed(seed)
iperm = sample(n)

# 3-fold cross-validation
# it takes at least 20 min to run this main function call due to quantile random forest involved
methodOutput = crossValidate(Kfold=3, iperm, kv_house_data_family_filtered_for_CV, nMLR=2)
methodOutput

saveRDS(methodOutput, "/Users/yujiech/Desktop/STAT 447/Group Project/methodOutput.rds")
# saveRDS(methodOutput, "/Users/liushuyan/Desktop/STAT447B/Project/methodOutput.rds")
```

```{r import performanceOutput saved}

performanceOutput = readRDS("/Users/yujiech/Desktop/STAT 447/Group Project/methodOutput.rds")
# performanceOutput = readRDS("/Users/liushuyan/Desktop/STAT447B/Project/methodOutput.rds")

```

```{r performance table - overall}

performanceOutputMLR_0.5 = performanceOutput$perfAverageMLR_0.5
performanceOutputMLR_0.8 = performanceOutput$perfAverageMLR_0.8

performanceOutputQRF_0.5 = performanceOutput$perfAverageQRF_0.5
performanceOutputQRF_0.8 = performanceOutput$perfAverageQRF_0.8

performance_table_MLR = rbind(performanceOutputMLR_0.5, performanceOutputMLR_0.8)[, -c(1, 5)]
colnames(performance_table_MLR) = c("avg length (all variables)", "IS (all variables)", "coverage rate (all variables)", "avg length (subset of variables)", "IS (subset of variables)", "coverage rate (subset of variables)")

performance_table_MLR_all_variables = round(performance_table_MLR[, 1:3], 2)
colnames(performance_table_MLR_all_variables) = c("avg length", "IS", "coverage rate")

performance_table_MLR_subset_of_variables = round(performance_table_MLR[, 4:6], 2)
colnames(performance_table_MLR_subset_of_variables) = c("avg length", "IS", "coverage rate")

performance_table_QRF = round(rbind(performanceOutputQRF_0.5, performanceOutputQRF_0.8)[, -1], 2)
colnames(performance_table_QRF) = c("avg length", "IS", "coverage rate")

performance_tables = list(performance_table_MLR=performance_table_MLR, performance_table_MLR_all_variables=performance_table_MLR_all_variables, performance_table_MLR_subset_of_variables=performance_table_MLR_subset_of_variables, performance_table_QRF=performance_table_QRF)

performance_tables

```

```{r performance table - each fold}

performanceOutputMLR_0.5_per_fold = performanceOutput$perfMatMLR_0.5
performanceOutputMLR_0.8_per_fold = performanceOutput$perfMatMLR_0.8

performanceOutputQRF_0.5_per_fold = performanceOutput$perfMatQRF_0.5
performanceOutputQRF_0.8_per_fold = performanceOutput$perfMatQRF_0.8

# For Multiple Linear Regression models - 50% PI 
performanceOutputMLR_0.5_per_fold = round(performanceOutputMLR_0.5_per_fold[, -5], 2)
rownames(performanceOutputMLR_0.5_per_fold) = c("fold 1", "fold 2", "fold 3")
colnames(performanceOutputMLR_0.5_per_fold) = c("prediction level", "avg length (all variables)", "IS (all variables)", "coverage rate (all variables)", "avg length (subset of variables)", "IS (subset of variables)", "coverage rate (subset of variables)")

# For Multiple Linear Regression models - 80% PI 
performanceOutputMLR_0.8_per_fold = round(performanceOutputMLR_0.8_per_fold[, -5], 2)
rownames(performanceOutputMLR_0.8_per_fold) = c("fold 1", "fold 2", "fold 3")
colnames(performanceOutputMLR_0.8_per_fold) = c("prediction level", "avg length (all variables)", "IS (all variables)", "coverage rate (all variables)", "avg length (subset of variables)", "IS (subset of variables)", "coverage rate (subset of variables)")

# For Quantile Random Forest - 50% PI 
rownames(performanceOutputQRF_0.5_per_fold) = c("fold 1", "fold 2", "fold 3")
colnames(performanceOutputQRF_0.5_per_fold) = c("prediction level", "avg length", "IS", "coverage rate")

# For Quantile Random Forest - 80% PI 
rownames(performanceOutputQRF_0.8_per_fold) = c("fold 1", "fold 2", "fold 3")
colnames(performanceOutputQRF_0.8_per_fold) = c("prediction level", "avg length", "IS", "coverage rate")

performance_tables_per_fold = list(performanceOutputMLR_0.5_per_fold=performanceOutputMLR_0.5_per_fold, performanceOutputMLR_0.8_per_fold=performanceOutputMLR_0.8_per_fold, performanceOutputQRF_0.5_per_fold=performanceOutputQRF_0.5_per_fold, performanceOutputQRF_0.8_per_fold=performanceOutputQRF_0.8_per_fold)

performance_tables_per_fold

```

```{r check summary of model fitted}
multiple_lm_model_subset_check = lm(unitPrice ~ ., data = kv_house_data_family_filtered_for_CV)
summary(multiple_lm_model_subset_check)
plot(multiple_lm_model_subset_check)
```




